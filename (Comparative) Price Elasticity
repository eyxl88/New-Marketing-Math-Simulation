# Price Elasticity and Comparative Price Elasticity

print("Welcome to Price Elasticity and Comparative Price Elasticity Practice!")

global completion

import random
import math

# Useful Randomized Sign Function
def random_sign(value=0):
    plus_minus = random.randint(0,1)
        if plus_minus == 0:
            value = -value
        return value

class Company():
    def __init__(self, sales_change_low, sales_change_high):
        self.sales_old = random.randint(500000, 10000000)
        self.sales_change = random_sign(random.randrange(sales_change_low, sales_change_low))
        self.sales_new = self.sales_old + self.sales_change

        self.price_old = round(random.uniform(10, 30), 2)
        self.price_change = random_sign(round(random.uniform(0, 7), 2))
        self.price_new = self.price_old + self.price_change

        self.incr_decr = "decreased" if self.price_change < 0 else "increased"

        # Set problem answer values
        self.change_demand = ((company.sales_new - company.sales_old) / company.sales_old) * 100
        self.change_price = ((company.price_new - company.price_old) / company.price_old) * 100
        self.price_elasticity = self.change_demand / self.change_price

        # Set short answer strings.
        if self.price_elasticity < -1:
            self.elastic = "elastic"
            self.recommendation = "decrease"
        elif self.price_elasticity > -1 and self.price_elasticity < 0:
            self.elastic = "inelastic"
            self.recommendation = "increase"
        elif math.floor(self.price_elasticity, 2) == 0 or math.ceil(self.price_elasticity, 2) == 0:
            self.elastic = "perfectlyinelastic"
            self.recommendation = "increase"
        elif math.floor(self.price_elasticity, 2) == -1 or math.ceil(self.price_elasticity, 2) == -1:
            self.elastic = "unitaryelastic"
            self.recommendation = "remainsconstant"

class ProblemAnswers():
    def __init__(self):
        self.price_elasticity = b.change_demand / a.change_price
        self.status = "complementary products" if self.price_elasticity < 0 \ 
                else "substitute products" if self.price_elasticity > 0

# General function to safely handle user input so the program does not break so easily.
def get_user_input(print_message, float_or_int):
    print(print_message, end="")
    user_input = input()
    while user_input != "give up":
        try:
            if float_or_int == float or float_or_int == int:
                if "," in user_input:
                    raise CommaError("Invalid input. Do not enter the , sign")
                if "%" in user_input:
                    raise PercentError("Invalid input. Do not enter the % sign.")
                if "$" in user_input:
                    raise DollarSignError("Invalid Input. Do not enter the $ sign.")
                user_input = float_or_int(user_input)
                return user_input
                break
            if float_or_int == "string":
                user_input_list = user_input.strip().lower().split() # Remove whitespace + capitalization
                for i in range(len(user_input_list[:])): # Iterate over copy of list of words.
                    temp_var = "" # Initialize puncutation removal variable.
                    for letter in user_input_list[:][i]: # For each letter in each word in the list
                        if letter.isalnum() and not letter.isdigit():
                            temp_var += letter # Add letters to the temp string (exclude numbers / puncutation)
                    user_input_list[i] = temp_var # Set list item equal to the transformed string.
                user_input = "".join(user_input_list) # Combine all list items back into one long string without spaces.
                return user_input

        except CommaError as excpt:
              print(excpt)
              user_input = input()
        except PercentError as excpt:
              print(excpt)
              user_input = input()
        except DollarSignError as excpt:
              print(excpt)
              user_input = input()
        except:
              print("Invalid Entry.")
              user_input = input()
    if user_input == "give up":
        return "give up"

# General class to group and print answer messages as created by instances.
class AnswerMessages:
    def __init__(self):
        self.correct = None
        self.input_precursor = ""
        self.try_again = f"\nTry again or enter \"give up\" to show the answer: {self.input_precursor}"
        self.wrong = None
    def print_msg(self, msg):
        if msg == 1:
            print(self.correct)
        if msg == 2:
            print(self.try_again)
        if msg == 3:
            print()
            print(self.wrong)

# Functions to check float and int values.

def check_float_value(user_val, value_to_check, instance_name):
    global completion
    value_low = value_to_check - 0.005
    value_high = value_to_check + 0.005
    if user_val == "give up":
        instance_name.print_msg(3)
        completion = True
    elif value_low < user_val < value_high:
        instance_name.print_msg(1)
        completion = True
    else:
        instance_name.print_msg(2)

def check_exact_value(user_val, value_to_check, instance_name):
    global completion
    if user_val == "give up":
        instance_name.print_msg(3)
        completion = True
    elif user_val == value_to_check:
        instance_name.print_msg(1)
        completion = True
    else:
        instance_name.print_msg(2)

def append_wrong_msg(value_to_check, answer, msg_instance):
    if answer < -1 and not (value_to_check < -1):
        msg_instance.wrong += f"\nIf price elasticity is less than -1, then the price elasticity is considered elastic."
    if answer == -1 and not(value_to_check == -1):
        f"If price elasticity is -1, then the price elasticity is considered unitary elastic.")
    f"If price elasticity is between -1 and 0 non-inclusive, price elasticity is considered inelastic." \
    f"If price elasticity is 0, then price elasticity is considered perfectly inelastic."
# FINISH THIS UP

# Initialize the classes for problem setup.
a = Company(200000, 2000000)
b = Company(1000, 1000000)
ans_ab = ProblemAnswers()

# Set up for Company A
print(f"Last year, Company A sold {a.sales_old:,d} units priced at ${a.price_old:.2f}.")
print(f"This year, Company A {a.inc_decr} the price to ${a.price_new:.2f} and sold {a.sales_new:,d} units.")

# Price Elasticity of Company A
a_price_elasticity = AnswerMessages()
a_price_elasticity.correct = f"Correct! The price elasticity for Company A is {a.price_elasticity:.2f}."
a_price_elasticity.wrong = f"The correct percent Price Elasticity for Company A was {a.price_elasticity:.2f}.")
              f"Price elasticity is the % change in demand divided by the % change in price.\n" \
              f"% change in demand is (new sales - old sales) / old sales * 100 or ({a_sales_new:,d} - {a_sales_old:,d}) / {a_sales_old:,d} * 100.\n" \
              f"% change in price is (new price - old price) / old price * 100 or ({a_price_new:.2f} - {a_price_old:.2f}) / {a_price_old:.2f} * 100.\n" \
              f"So the price elasticity is {a.change_demand}% / {a.change_price}%."

print()

completion = False
while completion == False:
    user_a_price_elasticity = get_user_input("Enter the Price Elasticity number of Company A, rounding to 2 decimal places: ", float)
    append_wrong_msg(user_a_price_elasticity, a_elastic_msg)
    check_float_value(user_a_price_elasticity, a.price_elasticity, a_price_elasticity)

a_elastic_msg = AnswerMessages()
a_elastic_msg.correct = f"Correct. Company A's price elasticity of {a.price_elasticity:.2f} means that the price is {a.elastic}"
a_elastic_msg.wrong = f"Company A's price elasticity was {a_elastic} because its price elasticity was {a_price_elasticity}."

completion = False
while completion == False:
    user_price_elastic = get_user_input("Enter \"Elastic\", \"Inelastic\", \"Unitary Elastic\" or \"Perfectly inelastic\" to describe price elasticity of Company A: ", "string")
    check_exact_value(user_price_elastic, a.elastic, a_elastic_msg)
    
print()
else:
    print(

print()
print("Enter \"increase\", \"remains constant\" or \"decrease\".")
user_a_recommendation = input("An 1% increase in price will mean that revenues ")
if user_a_recommendation == a_recommendation:
    print(f"Correct. Company A's product demand is {a_elastic} so an increase in price makes revenues {a_recommendation}.")
else:
    print(f"The correct answer was {a_recommendation} since Company A is {a_elastic}.")
    print(f"For elastic price elasticity, a 1% increase in price results in a greater decrease in demand and revenue.")
    print(f"For inelastic and perfectly inelastic PE, a 1% increase in price results in an overall increase in revenue.")
    print("since demand is not affected that much.")
    print(f"For unitary elastic PE, a 1% increase in price results in an equal decrease in demand, so revenue stays the same no matter what.")
print()

# Comparative Price Elasticity
# Set up for Company A and Company B
print(f"Last year, Company B sold {b_sales_old:,d} units but this year Company B sold {b_sales_new:,d}.")
print(f"Last year, Company A set its prices at ${a_price_old:.2f}.")
print(f"This year Company A {inc_decr} their prices to ${a_price_new:.2f}.")
print()

# Price Elasticity of Company A
user_ab_price_elasticity = float(input("Enter the Comparitive Price Elasticity for Companies A and B, rounding to 2 decimal places: "))

ab_price_elasticity_low = ab_price_elasticity - 0.005
ab_price_elasticity_high = ab_price_elasticity + 0.005

if ab_price_elasticity_low < user_ab_price_elasticity < ab_price_elasticity_high:
    print(f"Correct! The CPE for Companies A and B is {ab_price_elasticity:.3f} (3 decimal places for reference).")
else:
    print("Try again.")
    user_ab_price_elasticity = float(input())
    if ab_price_elasticity_low < user_ab_price_elasticity < ab_price_elasticity_high:
         print(f"Correct! The CPE for Companies A and B is {ab_price_elasticity:.3f} (3 decimal places for reference).")
    else:
         print("Try again. Last try.")
         user_ab_price_elasticity = float(input())
         if ab_price_elasticity_low < user_ab_price_elasticity < ab_price_elasticity_high:
              print(f"Correct! The CPE for Companies A and B is {ab_price_elasticity:.3f} (3 decimal places for reference).")
         else:
              print(f"The correct CPE for Companies A and B was {ab_price_elasticity:.3f} rounded up or down as necessary.")
              print(f"CPE is the % change in demand for Product B divided by the % change in price for Product A.")
              print(f"% change in demand is (new sales - old sales) / old sales * 100 or ({b_sales_new} - {b_sales_old}) / {b_sales_old} * 100.")
              print(f"% change in price is (new price - old price) / old price * 100 or ({a_price_new} - {a_price_old}) / {a_price_old} * 100.")
              print(f"So the CPE is {b_change_demand}% / {a_change_price}%.")
if ab_price_elasticity > 0:
    ab_sign = "positive"
if ab_price_elasticity < 0:
    ab_sign = "negative"

print()
print("Enter \"subsitute products\" or \"complementary products\" (capitalization matters)")
user_ab_status = input("Company A and Company B sell ")

if user_ab_status == ab_status:
    print(f"Correct. Company A and Company B sell {ab_status} since the CPE is {ab_price_elasticity} which is {ab_sign}.")
else:
    print(f"The correct answer was {ab_status} since their CPE is {ab_price_elasticity} which is {ab_sign}.")
    if ab_sign == "negative":
        print(f"When CPE is negative, this means that an increase in price in one results in a decrease in demand for the other.")
        print(f"Negative CPE means they are complementary products, like bread and butter, which are often bought in corelation to one another.")
        print(f"If one product becomes more expensive, people are less likely to buy it as well as other products which are used with it.")
    if ab_sign == "positive":
        print("When CPE is positive, this means that an increase in price in one results in an increase in demand for the other.")
        print(f"Positive CPE means they are subsitute products and people buy either one produce or the other.")
        print(f"If one becomes more expensive, demand for the other cheaper product will increase.")
